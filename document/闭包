# 闭包

## 闭包是什么

在 JavaScript 中，闭包是指一个函数能够访问其定义时所处的词法环境中的变量，即使该函数被调用时已经离开了该环境。这是因为该函数引用了该变量，并将该变量保存在其内部作用域中，形成了一个闭包。在JavaScript中，每个函数都是一个闭包，它可以访问函数定义时所处的作用域，包括局部变量、全局变量和其他函数的变量。闭包可以在函数内部创建，也可以作为函数的返回值返回。

## 闭包的原理

闭包的原理可以通过以下几个步骤来解释：

1. 当一个函数被定义时，它的作用域链被创建。作用域链是一个包含所有可访问变量的列表，它由当前函数的词法环境和所有外部函数的词法环境组成。
2. 当函数被调用时，它的执行环境被创建。执行环境是一个包含所有当前函数的变量的列表，它由当前函数的词法环境和所有外部函数的变量组成。
3. 如果函数内部有其他函数嵌套，那么这些内部函数可以访问外部函数的作用域链，并将其保存在自己的闭包中。
4. 当外部函数执行结束后，它的执行环境会被销毁，但是内部函数仍然可以访问它们的闭包中保存的外部函数变量。

让我们以一段示例代码来梳理这个流程

```
function closure() {
    let count = 1;
    return function () {
        count++;
        return count;
    }
}

console.log(closure()());
```

在这段代码中，我们依次执行了以下步骤：

1. 定义函数`closure`，其作用域链被创建，包含内部变量`count`和一个匿名函数
2. 定义匿名函数，其作用域链被创建，内部引用了父函数定义的变量`count`
3. 执行`closure`方法，`return`由于尾调，`closure`的执行环境会被销毁，`count`被销毁
4. 执行匿名函数。父函数的执行环境中的`count`被销毁。但在匿名函数的作用域链上，存在对`count`变量的引用。由于JS的标记回收机制，`count`变量不会被彻底销毁回收。匿名函数依然可以通过作用域链，来访问这个变量
5. 对匿名函数的作用域链上的`count`变量执行`++`操作并返回
6. 打印返回的结果

到这里，我们就可以很明确的得出，<b>闭包是词法作用域的体现</b>。

## 闭包的应用场景

然而，仅看以上内容，闭包除了会引发变量不释放导致的内存泄漏外，并没有体现出什么价值。但实际上，在JavaScript中，闭包的应用场景非常广泛，很多高级语法和特性，都是通过闭包来实现的。

常见的应用场景包括：

+ 模块化：使用闭包可以创建私有变量，以避免全局变量的污染。这种技术被广泛应用于JavaScript模块化中。

+ 记忆化：使用闭包可以缓存函数的计算结果，以提高代码性能。这种技术被广泛应用于函数式编程中。

+ 事件处理：使用闭包可以在事件处理程序中保留状态信息。例如，在JavaScript中，当点击一个按钮时，可以使用闭包来保存该按钮的状态信息。

+ 异步编程：使用闭包可以创建函数范围内的变量，以确保它们在异步回调中得到正确的值。

### 模块化

现代前端工程的代码量随着复杂度水涨船高，以及大量第三方的广泛使用，代码的拆分和连接成为了“刚需”。这种将代码拆分成独立的块，然后再把这些块连接起来的设计思路就是模块模式。逻辑分块、各自封装、相互独立、每个块自行决定对外暴露什么，自行决定引入执行哪些外部代码。这些基本的思想是JavaScript模块系统的基础。在这之中，如何实现私有变量，避免全局变量的污染，是非常重要的一个环节。

```
function counter() {
  let count = 0;
  function increment() {
    count++;
    console.log(count);
  }
  return increment;
}

const incrementCounter = counter();

incrementCounter();
incrementCounter(); 
incrementCounter(); 
```

在上面的例子中，`counter()`函数返回了一个内部函数`increment()`。由于`increment()`函数可以访问`count`变量，所以每次调用`incrementCounter()`函数时，都会在`count`变量上增加 1，然后将新的值打印出来。

由于`count`变量只能通过`increment()`函数访问，因此它是一个私有变量。其他代码无法直接访问`count`变量。通过这种方式，我们可以创建安全的代码，防止未经授权的代码访问和修改私有变量。

### 记忆化

记忆化缓存计算结果听起来可能很陌生，但是如果有在LeetCode修炼过算法与数据结构，那对这种手法一定不会陌生，让我们来看一个例子：

```
function memoizedFunction() {
  const cache = {};

  return function(arg) {
    if (arg in cache) {
      return cache[arg];
    }
    const result = 'result';
    cache[arg] = result;
    return result;
  }
}

const cachedFunction = memoizedFunction();

const result1 = cachedFunction(1);
const result2 = cachedFunction(1);
```

在这个例子中，我们在方法`memoizedFunction`中，声明了一个缓存对象`cache`，然后返回了一个匿名函数。之后声明`cachedFunction`来获取`memoizedFunction`中返回的缓存了计算结果的匿名函数。之后连续两次调用`cachedFunction`。在第一次调用时，缓存`cache`没有相关的内容，因此需要计算并缓存结果。到了第二次调用时，就直接从缓存中获取并返回结果了。在这个流程中，缓存对象`cache`无法被外部访问，只能通过`cachedFunction`来间接访问。


### 事件处理

JavaScript中的闭包在事件处理中具有广泛的应用。事件处理程序通常需要访问它们外部作用域中的变量，因此使用闭包可以方便地将变量绑定到事件处理程序中。具体来说，当事件处理程序被定义时，它可以捕获并保存外部作用域中的变量。这些变量将在事件处理程序被调用时仍然可用，即使它们不再在外部作用域中存在。

```
function setupCounter() {
  let count = 0;
  document.getElementById('counter').addEventListener('click', function() {
    count++;
    alert('Count: ' + count);
  });
}

setupCounter();
```

在这个例子中，`setupCounter()`函数定义了一个`count`变量，并为ID为"counter"的元素添加了一个单击事件处理程序。这个事件处理程序是一个匿名函数，它访问了`count`变量，并将其增加1。

由于事件处理程序是一个闭包，它可以访问`setupCounter()`函数的作用域中的`count`变量。因此，每次单击"counter"元素时，`count`变量的值将增加，并在弹出窗口中显示。

这种使用闭包的方式非常常见，因为它允许事件处理程序访问它们需要的变量，并且可以防止这些变量与其他代码发生冲突。

### 异步编程


